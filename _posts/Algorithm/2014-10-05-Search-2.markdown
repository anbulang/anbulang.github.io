---
layout: page
title: 查找2
catalog: Algorithm
tags: 二叉查找树 
image:
  feature: abstract-3.jpg
  credit: dargadgetz
  creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
comments: true
modified: 2014-10-05
---

## 二叉查找树

> **定义** 二叉查找树的每个结点都含有一对键和值且每个结点的键都大于其左子树中的任意结点的键而小于右子树中的任意结点的键。

### 基本实现
{% highlight java %}
public class BST<K extends Comparable<K>, V> {
    private Node root;  // 二叉查找树的根节点
    
    private class Node {
        private K key;
        private V value;
        private Node left, right;
        private int N;  // 该结点下所有子节点的数量
        
        public Node(K key, V value, int N) {
            this.key = key;
            this.value = value;
            this.N = N;
        }
    }
    
    /**
     * 获取所有节点的个数
     */
    public int size() {
        return size(root);
    }
    
    private int size(Node node) {
        if (node == null) return 0;
        else return node.N;
    }
    
    /**
     * 获取符号表中key所对应的value值
     */
    public V get(K key) {
        return get(root, key);
    }
    
    private V get(Node node, K key) {
        if (node == null) return null;
        int cmp = key.compareTo(node.key);
        if (cmp < 0) return get(node.left, key);
        else if (cmp > 0) return get(node.right, key);
        else return node.value;
    }
    
    /**
     * 更新或插入一个键值对
     */
    public void put(K key, V value) {
        // 查找key对应的节点，找到则更新该结点的值，未找到则创建新的结点
        root = put(root, key, value);
    }
    
    private Node put(Node node, K key, V value) {
        // 未找到节点则创建新的节点
        if (node == null) return new Node(key, value, 1);
        // 查找key
        int cmp = key.compareTo(node.key);
        if (cmp < 0)        node.left = put(node.left, key, value);
        else if (cmp > 0)   node.right = put(node.right, key, value);
        else                node.value = value;
        node.N = size(node.left) + size(node.right) + 1;
        return node;
    }
}
{% endhighlight %}

- 查找

![enter image description here](http://algs4.cs.princeton.edu/32bst/images/bst-search.png)

- 插入

![enter image description here](http://algs4.cs.princeton.edu/32bst/images/bst-insert.png)

### 分析

> 在由$N$个随机键够早的二叉查找树中，查找命中平均所需的比较次数为~$2lnN$，插入操作和查找未命中平均所需要的比较次数为~$2lnN$。

### 删除 

- 删除最小键

{% highlight java %}
/**
 * 删除最小键
 */
public void deleteMin() {
    root = deleteMin(root);
}

private Node deleteMin(Node node) {
    if (node == null) return null;
    // 不断检索左子树直到遇见空的左链接，返回该结点的右链接
    if (node.left == null) return node.right;
    node.left = deleteMin(node.left);
    node.N = size(node.left) + size(node.right) + 1;
    return node;
}
{% endhighlight %}

![enter image description here](http://algs4.cs.princeton.edu/32bst/images/bst-deletemin.png)

- 删除操作

{% highlight java %}
public void delete(K key) {
    root = delete(root, key);
}

public Node delete(Node node, K key) {
    if (node == null)   return null;
    // 现查找key所在的节点
    int cmp = key.compareTo(node.key);
    if (cmp < 0) node.left = delete(node.left, key);
    if (cmp > 0) node.right = delete(node.right, key);
    else {
        // 找到该结点先判断该结点的左右子树是否为空
        if(node.left == null) return node.right;
        if(node.right == null) return node.left;
        Node x = node;
        // 将node指向右子树中最小的节点
        node = min(x.right);
        // 删除右子树中最小的节点
        node.right = deleteMin(x.right);
        // 再令node的左子树指向原左子树的根节点
        node.left = x.left;
    }
    // 更新节点的N值
    node.N = size(node.left) + size(node.right) + 1;
    return node;
}

private Node min(Node node) {
    if (node == null) return null;
    if (node.left == null) return node;
    return min(node.left);
}
{% endhighlight %}
![enter image description here](http://algs4.cs.princeton.edu/32bst/images/bst-delete.png)

> 在一棵二叉查找树中，所有操作在最坏情况下所需的时间都与树的高度成正比。

