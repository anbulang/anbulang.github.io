---
layout: post
title: 设计模式—迭代器与组合模式
category: DesignPattern
tags: 迭代器模式 组合模式
image:
  feature: abstract-3.jpg
  credit: dargadgetz
  creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
comments: true
date: 2014-09-10
---

迭代器模式
==========


模式定义
-----------
>**迭代器模式**提供一种方法顺序的访问一个聚合对象中的各个元素，而又不暴露其内部的表示。
<!-- more -->

* 把游走的任务放在迭代器上，而不是集合上。这样简化了集合的接口和实现，也让责任各得其所。

模式类图
-----------
<a href="http://imgbox.com/iDFPI2J9" target="_blank"><img src="http://i.imgbox.com/iDFPI2J9.png" alt="image host"/></a>

* Java的Collection Framework提供另一种迭代器接口，称为ListIterator。这个迭代器在标准的迭代器接口上多加了一个previous()和一些其他的方法。任何实现了List接口的集合，都支持这样的做法。
* 迭代器意味着没有次序，只是取出所有的元素，并不表示取出元素的先后就代表元素的大小次序。

设计原则


-----------
>**单一责任**一个类应该只有一个引起变化的原因。

* 类的每个责任都有改变的潜在区域。超过一个责任，意味着超过一个改变的区域。这个原则告诉我们，尽量让每个类保持单一责任。
*  这一原则又叫做**内聚**。它用来度量一个类或模块紧密地达到单一目的或责任的程度。当模块或一个类被设计成只支持一组相关的功能时，我们说它具有高内聚；反之，当被设计支持一组不相关的功能时，我们说它具有低内聚。

组合模式
========

模式定义
-----------
>**组合模式**允许你将对象组合成树形结构来表现”整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。

* 在大多数情况下，使用组合模式，我们可以忽略对象组合和个别对象之间的差别。

模式类图
-----------
<a href="http://imgbox.com/uj24OLZz" target="_blank"><img src="http://i.imgbox.com/uj24OLZz.png" alt="image host"/></a> 

模式示例
-----------
* 我们需要某种树形结构，可以容纳菜单、子菜单和菜单项。
* 能够在每个菜单各个项之间游走，而且至少要像现在用迭代器一样方便。
* 能够有弹性的地在菜单项之间游走。
<a href="http://imgbox.com/rD0IgWxr" target="_blank"><img src="http://i.imgbox.com/rD0IgWxr.png" alt="image host"/></a>

* **MenuComponent**

```java
package pattern.composite;

/**
 * 抽象类，包括组合方法和操作方法，并提供默认实现
 * @  author Chaucer
 *
 */
public abstract class MenuComponent {
    
    public void add(MenuComponent menuComponent) {
        throw new UnsupportedOperationException();
    }
    
    public void remove(MenuComponent menuComponent) {
        throw new UnsupportedOperationException();
    }
    
    public MenuComponent getChild(int i) {
        throw new UnsupportedOperationException();
    }
    
    public String getName() {
        throw new UnsupportedOperationException();
    }
    
    public String getDescription() {
        throw new UnsupportedOperationException();
    }
    
    public double getPrice() {
        throw new UnsupportedOperationException();
    }
    
    public boolean isVegetarian() {
        throw new UnsupportedOperationException();
    }
    
    public void print() {
        throw new UnsupportedOperationException();
    }

}
```

* **MenuItem**

```java
package pattern.composite;

import static java.lang.System.out;

import java.util.Iterator;

/**
 * 菜单项
 * @  author Chaucer
 *
 */
public class MenuItem extends MenuComponent {
    
    String name;
    String description;
    boolean vegetarian;
    double price;
    
    public MenuItem(String name, String dsccription, boolean vegetarian, double price) {
        this.name = name;
        this.description = dsccription;
        this.vegetarian = vegetarian;
        this.price = price;
    }
    
    @ Override
    public String getName() {
        return name;
    }
    
    @ Override
    public String getDescription() {
        return description;
    }
    
    @ Override
    public double getPrice() {
        return price;
    }
    
    @ Override
    public boolean isVegetarian() {
        return vegetarian;
    }
    
    @ Override
    public void print() {
        out.print(" " + getName());
        if (isVegetarian()) {
            out.print("(v)");
        }
        out.println(", " + getPrice());
        out.println("    -- " + getDescription());
    }

    @ Override
    public Iterator<MenuComponent> iterator() {
        return new NullIterator();
    }
    
    /**
     * 空迭代器
     * @ author Chaucer
     *
     */
    private class NullIterator implements Iterator<MenuComponent> {

        @ Override
        public boolean hasNext() {
            return false;
        }

        @ Override
        public MenuComponent next() {
            return null;
        }

        @ Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
        
    }

}
```

* **Menu**

```java
package pattern.composite;

import java.util.ArrayList;
import java.util.Iterator;

import static java.lang.System.out;

/**
 * 菜单
 * @ author Chaucer
 *
 */
public class Menu extends MenuComponent {
    
    ArrayList<MenuComponent> menuComponents = new ArrayList<>();
    String name;
    String description;
    
    public Menu(String name, String description) {
        this.name = name;
        this.description = description;
    }

    @ Override
    public void add(MenuComponent menuComponent) {
        menuComponents.add(menuComponent);
    }

    @ Override
    public void remove(MenuComponent menuComponent) {
        menuComponents.remove(menuComponent);
    }

    @ Override
    public MenuComponent getChild(int i) {
        return menuComponents.get(i);
    }

    @ Override
    public String getName() {
        return name;
    }

    @ Override
    public String getDescription() {
        return description;
    }

    @ Override
    public void print() {
        out.print("\n" + getName());
        out.println(", " + getDescription());
        out.println("---------------------------------------");
        // 遍历每个子节点，如果子节点是菜单项，则调用他的print方法；
        // 如果子节点是子菜单，则递归调用菜单的print方法。
        for (MenuComponent com : menuComponents) {
            com.print();
        }
    }

    @ Override
    public Iterator<MenuComponent> iterator() {
        return new CompositeIterator(menuComponents.iterator());
    }
    
}
```

* **CompositeIterator**

```java
package pattern.composite;

import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Stack;

public class CompositeIterator implements Iterator<MenuComponent> {
    
    //维护迭代器在遍历中的位置
    Stack<Iterator<MenuComponent>> stack = new Stack<>();   
    
    public CompositeIterator(Iterator<MenuComponent> iterator) {
        stack.push(iterator);
    }

    @ Override
    public boolean hasNext() {
        if (stack.isEmpty()) 
            return false;
        Iterator<MenuComponent> iterator = stack.peek();
        if (!iterator.hasNext()) {
            stack.pop();
            return hasNext();
        }
        return true;
    }

    @ Override
    public MenuComponent next() {
        //排除非法操作
        if(hasNext()) throw new NoSuchElementException();
        
        Iterator<MenuComponent> iterator = stack.peek();
        MenuComponent com = iterator.next();
        if (com instanceof Menu) {
            //如果是菜单，则把该菜单的迭代器加入到栈中。
            //维护组合递归结构的位置。
            stack.push(com.iterator()); 
        }
        return com; 
    }

    @ Override
    public void remove() {
        throw new UnsupportedOperationException();
    }

}
```

* **Waitress**

```java
package pattern.composite;

import java.util.Iterator;

public class Waitress {
    
    MenuComponent allMenus;
    
    public Waitress(MenuComponent allMenus) {
        this.allMenus = allMenus;
    }
    
    public void printMenu() {
        allMenus.print();
    }
    
    public void printVegetarianMenu() {
        Iterator<MenuComponent> iterator = allMenus.iterator();
        System.out.println("\nVEGETARIAN MENU\n----------");
        while (iterator.hasNext()) {
            MenuComponent com = iterator.next();
            try {
                // 如果com是Menu，调用isVegetarian方法会抛出异常
                if (com.isVegetarian()) com.print();
            } catch (UnsupportedOperationException e) {
                // do nothing
            }
        }
    }

}
```

组合模式虽然违反了高内聚原则，但是它以此换取了透明性。即通过让组件的接口同时含有一些管理子节点和叶节点的操作，客户就可以将组合和叶节点一视同仁。
如果组合结构很复杂，或者遍历的代价太高，那么实现组合节点的缓存就很有必要。
