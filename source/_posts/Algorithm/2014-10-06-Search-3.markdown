---
layout: post
title: 查找3
catalog: Algorithm
tags: 平衡查找树 红黑树
image:
  feature: abstract-11.jpg
  credit: dargadgetz
  creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
comments: true
date: 2014-10-06
---
## 2-3查找树

> **定义** 一棵2-3树或为一棵空树，或有以下结点组成：


2-结点，含有一个键（及其对应的值）和两条链接，左链接指向的2-3树都小于该结点，右链接指向的2-3树都大于该结点。
3-结点，含有两个键（及其对应的值）和三条链接，左链接指向的2-3树都小于该结点，中链接指向的2-3树都位于该结点的两个键之间，右链接指向的2-3树都大于该结点。

<!-- more -->
![enter image description here](http://algs4.cs.princeton.edu/33balanced/images/23tree-anatomy.png)

### 查找
![enter image description here](http://algs4.cs.princeton.edu/33balanced/images/23tree-search.png)

### 插入
- 向2-结点中插入新键
如果未命中的查找结束于一个2-结点，只要把这个2-结点替换为一个3-结点，将要插入的键保存在其中即可。

![enter image description here](http://algs4.cs.princeton.edu/33balanced/images/23tree-insert2.png)



- 向一棵只含有一个3-结点的树中插入新键
先临时将新键存入该结点使之成为一个4-结点，然后分解4-结点为3个2-结点，树的高度加1。

![enter image description here](http://algs4.cs.princeton.edu/33balanced/images/23tree-insert3a.png)

- 向一个父结点为2-结点的3-结点中插入新键

先临时将新键存入该结点使之成为一个4-结点，将中键移动到原来的父结点中，将左右键分解为两个新的2-结点。

![enter image description here](http://algs4.cs.princeton.edu/33balanced/images/23tree-insert3b.png)

- 向一个父结点为3-结点的3-结点中插入新键

![enter image description here](http://algs4.cs.princeton.edu/33balanced/images/23tree-insert3c.png)

- 分解根节点
树的高度加1.

![enter image description here](http://algs4.cs.princeton.edu/33balanced/images/23tree-split.png)

- 局部变换
讲一个4-结点分解为一棵2-3树可能有6种情况，如下图。2-3树插入算法的根本在于这些变换都是局部的：除了相关的节点和链接之外不必修改或检查树的其他部分。

<a href="http://imgbox.com/ZGendVlY" target="_blank"><img src="http://i.imgbox.com/ZGendVlY.jpg" alt="image host"/></a>

> 在一棵大小为$N$的2-3树中，查找和插入操作访问的节点必然不超过$lgN$

## 红黑树
红黑树来代替2-3树，将3-结点表示为由一个左斜的红色链接相连的两个2-结点。
![enter image description here](http://algs4.cs.princeton.edu/33balanced/images/redblack-encoding.png)

- 红链接均为左链接
- 没有任何一个结点同时和两个红链接相连
- 完美黑色平衡，即任意空链接到根结点的路径上的黑色链接数量相同

### 表示

- 一一对应
![enter image description here](http://algs4.cs.princeton.edu/33balanced/images/redblack-1-1.png)

- 颜色表示
将颜色保存在Node中，指其父结点指向该结点的链接的颜色。约定空链接为黑色。

![enter image description here](http://algs4.cs.princeton.edu/33balanced/images/redblack-color.png)

### 旋转
当出现红色右链接或两条相连的红链接时通过旋转修复。

![enter image description here](http://algs4.cs.princeton.edu/33balanced/images/redblack-left-rotate.png )![enter image description here](http://algs4.cs.princeton.edu/33balanced/images/redblack-right-rotate.png)![enter image description here](http://algs4.cs.princeton.edu/33balanced/images/color-flip.png)

### 插入

- 向单个2-节点中插入新键
- 向树底部的2-结点插入新键

<a href="http://imgbox.com/r6rATqtd" target="_blank"><img src="http://i.imgbox.com/r6rATqtd.jpg" alt="image host"/></a> <a href="http://imgbox.com/DsjLjbm4" target="_blank"><img src="http://i.imgbox.com/DsjLjbm4.jpg" alt="image host"/></a>

- 向一棵3-结点树中插入新键

<a href="http://imgbox.com/hoAoAYWb" target="_blank"><img src="http://i.imgbox.com/hoAoAYWb.jpg" alt="image host"/></a>

- 向树底部的3-节点树中插入新键

<a href="http://imgbox.com/TdTl5RJr" target="_blank"><img src="http://i.imgbox.com/TdTl5RJr.jpg" alt="image host"/></a>

综上所述，在沿着插入点到根结点的路径上向上移动时在所经过的每个结点中顺序完成以下操作，就可以实现插入：

 1. 如果有自建店是红色的而左子结点是黑色的，进行左旋；
 2. 如果左子结点是红色的且它的左子结点也是红色的，进行右旋；
 3. 如果左右子节点均为红色，进行颜色转换。

<a href="http://imgbox.com/ol9z0I9B" target="_blank"><img src="http://i.imgbox.com/ol9z0I9B.jpg" alt="image host"/></a>

```java
public class RedBlackBST<K extends Comparable<K>, V> {
    private Node root;
    
    // 红黑常量
    private static final boolean RED = true;
    private static final boolean BLACK = false;
    
    private class Node {
        private K key;
        private V val;
        private Node left, right;
        private int N;  //记录这颗子树中节点的个数
        private boolean color;  //其父结点指向它的链接的颜色
        
        public Node(K key, V val, int N, boolean color) {
            this.key = key;
            this.val = val;
            this.N = N;
            this.color = color;
        }
    }
    
    private boolean isRed(Node x) {
        if (x == null) return false;
        return x.color == RED;
    }
    
    private int size(Node x) {
        if (x == null) return 0;
        return x.N;
    }
    
    /**
     * 左旋操作
     */
    private Node rotateLeft(Node h) {
        Node x = h.right;
        h.right = x.left;
        x.left = h;
        // 改变颜色
        x.color = h.color;
        h.color = RED;
        // 重新统计子节点的数量
        x.N = h.N;
        h.N = size(h.left) + size(h.right) + 1;
        return x;
    }
    
    /**
     * 右旋操作
     */
    private Node rotateRight(Node h) {
        Node x = h.left;
        h.left = x.right;
        x.right = h;
        // 改变颜色
        x.color = h.color;
        h.color = RED;
        // 重新统计子结点的数量
        x.N = h.N;
        h.N = size(h.left) + size(h.right) + 1;
        return x;
    }
    
    private void flipColors(Node h) {
        h.color = RED;
        h.left.color = BLACK;
        h.right.color = BLACK;
    }
    
    /**
     * 插入操作
     */
    public void put(K key, V val) {
        root = put(root, key, val);
        // 颜色转换有可能使根节点变为红色，所以每次插入后都要确保root为黑色
        root.color = BLACK;
    }
    
    private Node put(Node h, K key, V val) {
        if (h == null) {
            return new Node(key, val, 1, RED);
        }
        
        int cmp = key.compareTo(h.key);
        if (cmp < 0)        h.left = put(h.left, key, val);
        else if (cmp > 0)   h.right = put(h.right, key, val);
        else                h.val = val;
        
        if (isRed(h.right) && !isRed(h.left))       h = rotateLeft(h);
        if (isRed(h.left) && isRed(h.left.left))    h = rotateRight(h);
        if (isRed(h.left) && isRed(h.right))        flipColors(h);
        
        h.N = size(h.left) + size(h.right) + 1;
        return h;
    }
}
```
![enter image description here](http://algs4.cs.princeton.edu/33balanced/images/redblack-construction.png)
其他实现请参照[RedBlackBST.java](http://algs4.cs.princeton.edu/33balanced/RedBlackBST.java.html)

## 比较
<a href="http://imgbox.com/Xig3QprB" target="_blank"><img src="http://i.imgbox.com/Xig3QprB.jpg" alt="image host"/></a>

